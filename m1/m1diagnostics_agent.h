/*
 *  Copyright (c) 2017 Medium One, Inc
 *  www.mediumone.com
 *
 *  Portions of this work may be based on third party contributions.
 *  Medium One, Inc reserves copyrights to this work whose
 *  license terms are defined under a separate Software License
 *  Agreement (SLA).  Re-distribution of any or all of this work,
 *  in source or binary form, is prohibited unless authorized by
 *  Medium One, Inc under SLA.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#ifndef INCLUDE_M1DIAGNOSTICS_AGENT_H_
#define INCLUDE_M1DIAGNOSTICS_AGENT_H_


#include <nx_api.h>
#include <nxd_dns.h>
#include <r_adc_api.h>
#include <m1.h>


typedef struct {
	char serial_number[101];
	char model_number[101];
	char email_address[255];
	char fw_version[20];
} m1_diag_initdata_t;

#define FOREACH_LOG_LEVEL(LOG_LEVEL) \
				LOG_LEVEL(debug)   \
        LOG_LEVEL(info)   \
				LOG_LEVEL(warn)   \
        LOG_LEVEL(error)  \

#define GENERATE_ENUM(ENUM) ENUM,
#define GENERATE_STRING(STRING) #STRING,

typedef enum {
    FOREACH_LOG_LEVEL(GENERATE_ENUM)
} LOG_LEVEL;

typedef enum {
	M1_DIAG_INT,
	M1_DIAG_FLOAT,
	M1_DIAG_STRING,
	M1_DIAG_BOOL
} periphery_type_t;

typedef struct {
	unsigned char memory_access:1;
	int * ready;
	union {
		volatile void * address;
		int (*int_fn)();
		char * (*char_fn)();
		float (*float_fn)();
	} accessor;
} periphery_access_t;


int m1_diag_start(const char * mqtt_url,
                    int mqtt_port,
                    const project_credentials_t * project,
                    const user_credentials_t * registration,
                    user_credentials_t * device,
                    const char * device_id,
                    int retry_limit,
                    int retry_delay,
                    int mqtt_heart_beat,
                    int tls_enabled,
					void * ssl_mem,
					int ssl_mem_size,
                    NX_PACKET_POOL * p_ppool,
                    NX_IP * p_ip,
                    NX_DNS * p_dns,
                    unsigned int diag_interval,
                    m1_diag_initdata_t * initdata,
                    LOG_LEVEL logging_level,
                    adc_instance_t * adc_inst
                    );
int m1_diag_start_2(m1_connect_params * params,
                    unsigned int diag_interval,
                    m1_diag_initdata_t * initdata,
                    LOG_LEVEL logging_level,
                    adc_instance_t * adc_inst);

/*
 *
 */
void m1_diag_stop();

/*
 * Description:
 * 		This sends a log event to Medium One. This is a non-blocking call.
 * Parameters:
 * 		message: log message; null-terminated string
 * 		code: int
 * 		function_name: null-terminated string
 * 		line_number: int
 * 		observed_at: ISO8601-format datetime string. If NULL, not included in event
 * 		(observed_at generated by M1 broker on reception)
 * 			eg. "2016-08-29T16:03:12.794925-07:00"
 * Errors:
 * 		M1_DIAG_ERROR_NOT_CONNECTED
 * 		M1_DIAG_ERROR_NULL_PAYLOAD
 * 		M1_DIAG_ERROR_UNABLE_TO_PUBLISH
 * Success:
 * 		return 0
 */
int m1_diag_log(LOG_LEVEL log_level, const char * message, int code, const char * function_name, int line_number, const char * observed_at);

#define M1_LOG(log_level, msg, code) do {m1_diag_log(log_level, msg, code, __func__, __LINE__, NULL);} while (0)

/*
 * Description:
 * 		This sends a json event to Medium One. This is a non-blocking call.
 * Parameters:
 * 		json_payload: serialized JSON object to send to Medium One
 * 			eg. "{\"my_key\": 12345}"
 * 		observed_at: ISO8601-format datetime string. If NULL, not included in event
 * 		(observed_at generated by M1 broker on reception)
 * 			eg. "2016-08-29T16:03:12.794925-07:00"
 * Errors:
 * 		M1_DIAG_ERROR_NOT_CONNECTED
 * 		M1_DIAG_ERROR_NULL_PAYLOAD
 * 		M1_DIAG_ERROR_UNABLE_TO_PUBLISH
 * Success:
 * 		return 0
 */
int m1_diag_publish_event(char * json_payload, char * observed_at);

/*
 * 	Description:
 * 		This function registers a callback function which is called when a message is received from Medium One.
 * 	Parameters:
 * 		subscription_callback: function pointer to callback
 * 			Callback function parameters:
 * 				type: type of message received (1 - cloud to device; 2 - cloud to group)
 * 				topic: full topic identifier for received message (null-terminated string)
 * 				msg: message content
 * 				length: message length
 * 	Errors:
 * 		M1_DIAG_ERROR_NULL_CALLBACK
 * 	Success:
 * 		return 0
 */
int m1_diag_register_subscription_callback(void (* subscription_callback)(int type, char * topic, char * msg, int length));

/*
 *
 */
int m1_diag_update_configuration(char * config);

/*
 *
 */
int m1_diag_update_gps(char * geopoint);

/*
 *
 */
int m1_diag_register_periphery(char * name, periphery_type_t type, periphery_access_t * peripheral);

/*
 *
 */
int m1_diag_register_humidity(periphery_access_t * humidity_pct);

/*
 *
 */
int m1_diag_register_current(periphery_access_t * current_ma);

/*
 *
 */
int m1_diag_register_power(periphery_access_t * power_mwatts);

/*
 *
 */
int m1_diag_register_battery(periphery_access_t * battery_pct);

/*
 *
 */
int m1_diag_register_acceleration(periphery_access_t * x_g, periphery_access_t * y_g, periphery_access_t * z_g);

/*
 *
 */
void m1_diag_ADC_Done_Callback(adc_callback_args_t * p_args);

#endif /* INCLUDE_M1DIAGNOSTICS_AGENT_H_ */
